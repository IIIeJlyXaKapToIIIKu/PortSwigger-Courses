## Exploiting Race Conditions When Uploading Files
Modern frameworks are better at protecting against these types of attacks. They typically don't upload files directly to the target `filesystem`. Instead, they take precautions like uploading to a temporary isolated directory first and randomizing the name to avoid overwriting existing files. They then perform validation on this temporary file and only transfer it to the destination once it is deemed safe.

However, developers sometimes implement their own file upload handling independent of any framework. Not only is this quite difficult to do well, but it can also lead to dangerous race conditions that allow an attacker to bypass even the most robust validation entirely.

For example, some websites upload a file directly to the main `filesystem` and then delete it again if it fails validation. This behavior is typical for websites that rely on anti-virus software and the like to check for malware. This may only take a few milliseconds, but in the short time the file exists on the server, an attacker can still potentially execute it.

These vulnerabilities are often extremely subtle, making them difficult to discover during `blackbox testing` unless we can find a way to leak the relevant source code.

## Race conditions in URL file uploads
Such race conditions can occur in functions that allow a file to be uploaded by providing a `URL`. In this case, the server must retrieve the file over the internet and create a local copy before it can perform any verification.

Since the file is uploaded using `HTTP`, developers cannot use their framework's built-in mechanisms to safely verify files. Instead, they can manually create their own processes to temporarily store and verify the file, which may not be as safe.

For example, if a file is uploaded to a temporary directory with a random name, an attacker should theoretically not be able to exploit any race conditions. If they don't know the directory name, they won't be able to request the file to trigger its execution. On the other hand, if the random directory name is generated using pseudo-random functions like `uniqid()` in `PHP`, it can potentially be brute-forced.

To make such attacks easier, we can try to increase the time it takes to process the file, thereby increasing the window for brute-forcing the directory name. One way to do this is to upload a larger file. If it is processed in chunks, we can potentially exploit this by creating a malicious file with the payload at the beginning, followed by a large number of random padding bytes.