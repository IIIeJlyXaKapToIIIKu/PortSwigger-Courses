## Exploiting insufficient file upload validation

In real life, it is unlikely to encounter a site without any protection at all, as in the previous lab. But the presence of protection does not guarantee its reliability. Sometimes it is possible to exploit the shortcomings of these mechanisms to obtain a web shell and execute remote code.

## Insufficient file type validation

When sending `HTML forms`, the browser usually uses `Content-Type: application/x-www-form-url-encoded`. This is suitable for text data (name, address), but not for binary files (images, `PDF`). In such cases, `Content-Type: multipart/form-data` is used.

An example of a form with an image upload, description, and username:
```Request
POST /images HTTP/1.1
Host: normal-website.com
Content-Length: 12345
Content-Type: multipart/form-data; boundary=-------------------------012345678901234567890123456

----------------------------012345678901234567890123456
Content-Disposition: form-data; name="image"; filename="example.jpg"
Content-Type: image/jpeg

[...binary content example.jpg...]

----------------------------012345678901234567890123456
Content-Disposition: form-data; name="description"

This is an interesting description of my image.

----------------------------012345678901234567890123456
Content-Disposition: form-data; name="username"

wiener
---------------------------012345678901234567890123456--
```

As you can see:
1. The request body is divided into parts for each form field.
2. Each part contains `Content-Disposition` (information about the field).
3. Parts can have their own `Content-Type` (`MIME-type` of the submitted data).

**Vulnerability**: If a site only checks the `Content-Type` of a part (for example, allowing only `image/jpeg`), but **does not check the actual content** of the file, the protection can be easily bypassed with tools like `Burp Repeater` by replacing the header.