## SSRF with whitelist-based input filtering
Some applications only allow input that matches a whitelist of allowed values. The filter may look for a match at the beginning of the input or within it. It is possible to bypass this filter by exploiting inconsistencies in URL parsing.

The URL specification has a number of features that are often overlooked when implementing ad-hoc parsing and validation:

- You can embed credentials in the URL before the hostname using the `@` character. For example:

```URL
https://expected-host:fakepassword@evil-host
```
- You can use the `#` character to specify a URL fragment. For example:

```URL
https://evil-host#expected-host
```
- You can leverage the DNS hierarchy by placing the required value in a fully qualified domain name that you control. For example:
```URL
https://expected-host.evil-host
```
- You can use URL encoding of characters to confuse the parser. This is especially useful if the filter code handles encoded characters differently than the backend. You can also try double encoding: some servers recursively decode the input, which causes discrepancies.
- You can combine these methods.