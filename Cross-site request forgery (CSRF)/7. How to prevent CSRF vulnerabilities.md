In this section, we will provide general recommendations on how you can protect your own websites from the types of vulnerabilities we demonstrated in our CSRF labs.
## Use CSRF tokens

The most reliable way to protect against CSRF attacks is to include a CSRF token in the relevant requests. The token should meet the following criteria:
- Unpredictable with high entropy, like session tokens in general.
- Associated with the user's session.
- Strictly validated in all cases before performing the corresponding action.
### How should CSRF tokens be generated?
CSRF tokens should contain significant entropy and be highly unpredictable, having the same properties as session tokens in general.
A cryptographically secure pseudo-random number generator (CSPRNG) initialized with a timestamp of the moment of creation plus a static secret should be used.
If additional assurance beyond the strength of the CSPRNG is required, individual tokens can be generated by concatenating its output with some user-supplied entropy and applying a strong hash to the entire structure. This creates an additional barrier to attackers attempting to analyze tokens based on the samples they are given.
### How should CSRF tokens be transmitted?
CSRF tokens should be treated as secrets and kept secure throughout their lifecycle. A commonly effective approach is to pass the token to the client inside a hidden field in an HTML form that is submitted using the POST method. The token will be included as a query parameter when the form is submitted:
```HTML
<input type="hidden" name="csrf-token" value="CIwNZNlR4XbisJF39I8yWnWX9wX4WFoz" />
```
For additional security, the field containing the CSRF token should be placed as early in the HTML document as possible, preferably before any non-hidden input fields and before any places where user-controlled data is injected into the HTML. This reduces the risk of various techniques where an attacker can use specially crafted data to manipulate the HTML document and capture parts of it.

> **Note**  
> The alternative approach of placing the token in the URL query string is slightly less secure, since the query string:
> - Is logged in various places on the client and server;
> - Can be passed to third parties via the HTTP Referer header;
> - May be displayed on-screen in the user's browser.

Some applications pass CSRF tokens via a custom request header. This provides additional protection against an attacker who was able to predict or capture another user's token, since browsers typically do not allow custom headers to be sent cross-domain. However, this approach limits the application to making CSRF-protected requests using XHR only (as opposed to HTML forms) and may be overly complex for many situations.
CSRF tokens must not be passed via cookies.
### How should CSRF tokens be validated?
When a CSRF token is generated, it MUST be stored on the server in the user's session data. When a subsequent request requiring validation is received, the server application MUST verify that the request contains a token whose value matches the one stored in the user's session. This validation MUST be performed regardless of the HTTP method or content type of the request. If a request does not contain a token, it MUST be rejected in the same way as a request with an invalid token.
## Use strict SameSite restrictions for cookies
In addition to implementing strong CSRF token validation, we recommend explicitly setting your own SameSite restrictions for each cookie you issue. By doing this, you can control exactly in which contexts a cookie will be used, independent of the browser.
Even if all browsers eventually adopt the "Lax by default" policy, this is not appropriate for every cookie and can be more easily circumvented than strict restrictions. Meanwhile, the inconsistency between different browsers also means that only a subset of your users will benefit from any SameSite restrictions.
It is ideal if you use the `Strict` policy by default, lowering it to `Lax` only if you have a good reason to do so. Never disable SameSite restrictions with `SameSite=None` unless you are fully aware of the security implications involved.
## Be careful with cross-origin, same-site attacks
While properly configured SameSite restrictions provide good protection against cross-site attacks, it is important to understand that they are completely helpless against cross-origin, same-site attacks.
If possible, we recommend isolating unsafe content, such as user-uploaded files, on a separate site from any sensitive functionality or data. When testing a site, be sure to thoroughly test all available attack surfaces belonging to the same site, including any of its sibling domains.