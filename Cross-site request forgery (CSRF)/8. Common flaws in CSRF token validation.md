CSRF vulnerabilities typically arise from improper validation of CSRF tokens. In this section, we will look at some of the most common issues that allow attackers to bypass these protections.
Some applications correctly validate the token when the request uses the `POST` method, but skip validation when the `GET` method is used.
In this situation, an attacker can switch to the `GET` method to bypass validation and perform a CSRF attack:
```Request
GET /email/change?email=pwned@evil-user.net HTTP/1.1
Host: vulnerable-website.com
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm
```
---
Some applications correctly validate the token when it is present, but skip validation when the token is not present.
In this situation, an attacker can remove the entire parameter containing the token (not just its value) to bypass validation and perform a CSRF attack:
```Request
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 25
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm

email=pwned@evil-user.net
```
---
Some applications do not validate that the token belongs to the same session as the user making the request. Instead, the application maintains a global pool of tokens that it has issued and accepts any token from that pool.
In this situation, an attacker can log into the application using their own account, obtain a valid token, and then pass that token to the victim user in their CSRF attack.

---
A variation on the previous vulnerability: some applications associate the CSRF token with a cookie, but not with the same cookie used for session tracking. This can easily happen when an application uses two different frameworks - one for session management and one for CSRF protection - that are not integrated together:
```Request
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv

csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
```
In this situation, exploitation is more difficult, but still possible. If the site has any behavior that allows an attacker to set a cookie in the victim's browser, the attack is possible. The attacker can log into the application using their own account, obtain a valid token and its associated cookie, exploit the cookie-setting behavior to place their cookie in the victim's browser, and pass their token to the victim user in their CSRF attack.

> **Note**  
> The cookie-setting behavior does not have to exist in the same web application as the CSRF vulnerability. Any other application in the same shared DNS domain could potentially be used to set a cookie on the target application, as long as the controlled cookie has the appropriate scope. For example, the cookie-setting functionality on staging.demo.normal-website.com could be used to set a cookie that would be sent to secure.normal-website.com.

--
In a further variation on the previous vulnerability, some applications do not keep any record of issued tokens on the server side, but instead duplicate each token inside a cookie and a query parameter. When subsequently validating the request, the application simply checks that the token sent in the query parameter matches the value sent in the cookie. This is sometimes called "double-submit" protection against CSRF and is recommended because it is easy to implement and does not require server-side state:
```Request
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```
In this situation, an attacker can again perform a CSRF attack if the site has a cookie-setting feature. Here, the attacker does not need to obtain a valid token. It simply makes up a token (possibly in the required format, if this is verified), uses cookie setting behavior to place its cookie in the victim's browser, and passes its token to the victim user in its CSRF attack.